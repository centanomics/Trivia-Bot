# HW 5 - Reflection 

### Design

1. What was most helpful about thinking about design and architecture of your project?

The most helpful aspect of design and architecture that was most helpful for our project was the use of use cases, and the use of UML diagrams in order to formulate the concept of our bot into subparts. These subparts allowed our group to understand the project a lot better, and be able to tackle the various levels that which the project needed to be completed. When creating these UML and architecture diagrams, since I am a visual learner, it alleviated the stress when beginning the project with the group.

2. What was most difficult? What would you do differently?

The most difficult aspect of designing our project was the understanding of how to implement a discord bot from scratch without the prior knowledge of how a discord bot is created. Even with the prior understanding of the design and how the tools were connected, trying to implement the bot from the design was rather difficult at the start. What I would have done differently would have been the prior research of how bots are generally created. 

3. What design methods might you want to try again in the future on another project?

The design methods that I would like to try again in the future is the importance of structuring the code to be more object oriented. Despite the time frame of our project, we were not able to implement more OOP into our program for better structuring. So in the future, with more research under my belt, being able to implement and learn more about OOP would be a game changer for future projects in structuring and studying code.


### Testing

1. What was most helpful about implementing, testing, and integration in your bot project?

The most helpful part about implementing and integration in our bot project was two fold. One was the addition of branches and PR requests so that we didn't run into too many merge conflicts. Whenever any of us wanted to work on the project, we created a new branch, no matter how small the addition or change we did to the code. And of course, many commits were made so that all of our code would be up to date. In terms of integration, we used a tool called a Heroku bot, which allowed for continuous integration anytime we merged branches into main. This represented the main bot that would have the core commands and work flow of the Trivia Bot, and it would always be running (compared to individual bots that needed to be activated manually)

The most helpful tests that we implemented into our project was our own version of unit tests. When we created the project, we all made our own discord bots so that whenever we tackled any issues that were assigned to us, we can immediately test it in our local files. This allowed us to continuously test anything that we needed to test without the added step of installing testing features into our project.

2. What was most difficult? What would you do differently?

The most difficult implementation of this project was understanding how to structure our code. Since we didn't have as much time, all of our bot code is under one JS file, which is horrendous for reworks and enhancements in our code. Although, we added a ton of comments for those that wish to read and understand our code from the ground up. What I would have done differently would be to structure the code a lot cleaner and separate the code into different files so that it would be easier to understand. 

3. What testing methods might you want to try again in the future on another project?

The testing methods that I would want to try again in the future are the use of testing in local channels and the integration using Heroku. Being able to have that continuous integration was really interesting to use and test while implementing the project. And being able to test locally without interrupting or getting in the way of the main code was an amazing tool for creating a bot that will be used by the whole group. These testing methods were amazing in a group, and I can definitely see myself 
using it for solo projects as well.

### Process

1. What was most helpful about implementing kanban and code review in your project?

During our process, the implementation of the kanban board allowed for easy tracking, scheduling, and delegating of tasks for the entirety of the project. Whenever there were issues that were mentioned during team meetings, it would be implemented into the kanban for future delegation. And when these issues were made, they were labeled so that we all understood the importance of each issue made. PRs were crucial into merging these completed issues into the main branch, and with that came code review. Code review was helpful in that we all understood what work we have done throughout the project, and it provided much needed clear and constant communication throughout the course of the project. And this allowed for great constructive criticism and comments that needed to be put in place for each of the PRs (if needed).

2. What was most difficult? What would you do differently?

The most difficult aspect of these processes was the understanding of everyone's code during code reviews. Whenever big changes were made, it could be quite difficult understanding how your teammates implemented the changes they made or the logic that they used. This can lead to delays in code reviews and much more of a need for meetings to discuss how things/code may have changed over the last coding session. What I would do differently would be the implementation of better code structure and descriptive comments for the code and PRs so that teammates know the code that we are doing at all times.

3. What software processes or practices might you want to try again in the future on another project?

The software processes that I would love to try again is the use of issues and the kanban board for scheduling tasks that I would like to complete in a project. Since this was my first time working with issues, I realized how amazing using issues in GitHub can be. And using the kanban board to visualize and understand the different issues and tasks that a project group has to do can be amazing in the long run for long term projects. 

### Overall

Considering all the design and architecture methods, testing practices, and software processes you've encountered---**compare and constrast** how the benefits of the different practices and how they might be useful together.

With all of the different design methods, testing practices, and software processes used within this project, when projects are implemented, all of these tools can be used fluently and in tandem to create a powerful yet simple design process for a long project. The design methods allow for the creation of the project to be fleshed out; great way to get the full picture of the project before actually implementing the project. Design methods such as use cases allow the team to understand the workflow and overall use of the project, architecture diagrams allow the team to understand how the many different tools that will be implemented are interconnected, while class diagrams gives an understanding of how the code will be structured. 

This goes right into the software processes and testing practices. The processes allows for the project to be fleshed out once the workflow is determines. This is used with kanban boards and issues so that while the implementation of the project is being done, bugs and fixes can be tracked and reported. And the continuous integration and unit testing that is done while these issues are being completed are crucial to make sure that you have covered all possible outcomes from the project. 

All of these methods allows for a seamless workflow for the timeline of the project. While design methods help initialize the project to understand the main goal, software processes allow for a pathway in order to reach that main goal (while tackling obstacles along the way), and testing makes sure that the goal is reach to it's max potential.